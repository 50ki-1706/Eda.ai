# 技術選定理由

## 概要

本プロジェクトはハッカソン（1 週間）で開発されたチャットアプリケーションである。
限られた期間内で最大の開発生産性を発揮するため、以下の 3 つの軸で技術を選定した。

1. **型安全性** — チーム間のコミュニケーションコストを削減する
2. **デプロイ容易性** — インフラ構築に時間を割かず開発に専念する
3. **チームメンバーの経験** — 学習コストを最小化する

---

## 選定軸 1: 型安全性

### TypeScript

フロントエンドからバックエンドまで TypeScript で統一することで、API の仕様に関する口頭・ドキュメントベースのコミュニケーションを最小化した。
型定義がそのまま API 仕様書の役割を果たすため、短期間のチーム開発においてミスコミュニケーションによるバグを防止できる。

### tRPC

tRPC を採用することで、バックエンドのエンドポイント定義がそのままフロントエンドの型として伝播する。
REST API のように OpenAPI スキーマを別途管理したり、型定義を手動で同期する必要がない。

**他の選択肢を選ばなかった理由**:

- **REST API**: エンドポイントの型定義をフロント・バックで二重管理する必要があり、1 週間の開発では同期コストが高い

---

## 選定軸 2: デプロイ容易性

### Next.js + Vercel

Next.js と Vercel の組み合わせにより、Git push のみでデプロイが完了する。
CI/CD パイプラインの構築やサーバーの運用管理が不要なため、ハッカソン期間中はアプリケーション開発に専念できた。

### Supabase

Supabase はマネージド PostgreSQL を即座に利用開始でき、データベースのセットアップにかかる時間を大幅に削減できる。
また、PostgreSQL ベースであるため Prisma（ORM）がそのまま利用可能であり、技術スタックとの親和性が高い。

**他の選択肢を選ばなかった理由**:

- **AWS (RDS, EC2 等)**: インフラ構築・運用に時間がかかり、1 週間のハッカソンではオーバーヘッドが大きい
- **Firebase (Firestore)**: Firestore はドキュメント指向の NoSQL であり、JSON ライクな「ドキュメント」を単位としてデータを保存する。スキーマレスで柔軟なデータ構造を持てる反面、本プロジェクトのデータモデルには以下の理由で不向きである。
  - **JOIN ができない**: Chat → Branch → Message（各 1:N）のリレーションを扱う際、複数コレクションに個別クエリを発行する必要がある
  - **再帰クエリがない**: Branch や Message は再帰的な親子関係（木構造）を持つが、PostgreSQL の再帰 CTE（WITH RECURSIVE）のような仕組みがなく、アプリ側でループして親を辿る必要がある
  - **データ整合性の担保が困難**: 外部キー制約がないため、データの整合性をアプリケーション側で制御する必要がある

---

## 選定軸 3: チームメンバーの経験

### TypeScript（再掲）

チームメンバー全員が TypeScript サークル出身であり、TypeScript での開発経験を持っている。
新しい言語の学習コストをゼロにすることで、1 週間という制約の中で機能開発に集中できた。
