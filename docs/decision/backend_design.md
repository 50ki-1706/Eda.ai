# バックエンド設計選定理由

## 概要

本プロジェクトのバックエンドは **2 層構造（Controller / Repository）** を採用している。
チーム開発における可読性・保守性を確保しつつ、小規模アプリケーションを短期間で構築するための設計判断である。

---

## 2 層構造（Controller / Repository）の採用理由

### なぜ責務を分割するのか

ハッカソンとはいえチーム開発であるため、可読性と保守性の確保は不可欠である。
Controller と Repository で責務を分けることで、以下のメリットを得ている。

- **各ファイルの役割が明確**: どこにビジネスロジックがあり、どこにデータアクセスがあるかが一目でわかる
- **並行開発が容易**: メンバー間でファイルの競合が起きにくい
- **コードレビューの効率化**: 変更の影響範囲が限定される

### なぜ 2 層なのか（Service 層を設けなかった理由）

一般的なバックエンド設計では Controller → Service → Repository の 3 層構造があるが、本プロジェクトでは意図的に Service 層を省略した。

- **小規模アプリケーション**: ドメインロジックが複雑ではなく、Service 層の抽象化はオーバーエンジニアリングとなる
- **短期間での開発**: 1 週間のハッカソンにおいて、レイヤーを増やすことは開発速度の低下に直結する
- **経験が少ないメンバーへの配慮**: シンプルな 2 層構造は理解しやすく、全メンバーが迷わずコードを書ける

---

## 各層の責務

### Controller 層

**責務**: ビジネスロジックの実装、ユースケースの調整

- Repository と LLM Provider を組み合わせて、一つのユースケースを完結させる
- データの永続化は行わない（Repository に委譲）
- 外部サービスとの直接通信は行わない（LLM Provider に委譲）

### Repository 層

**責務**: データベースアクセスの抽象化

- Prisma Client を使用した CRUD 操作のみを行う
- ビジネスロジックを持たない
- トランザクションや複雑なクエリ（再帰 CTE 等）もこの層に閉じ込める

---

## LLM Provider パターン

本プロジェクトでは複数の LLM（Gemini / OpenRouter）を切り替えて利用する要件があったため、**Provider パターン** で抽象化した。

- 共通の `LLMProvider` インターフェースを定義し、各プロバイダーが実装する
- ファクトリ関数 `getLLMProvider(provider)` で動的にプロバイダーを切り替え
- 新しいプロバイダーを追加する際に、既存コードを変更する必要がない（開放閉鎖原則）

Controller は `LLMProvider` インターフェースにのみ依存するため、LLM プロバイダーの詳細を意識せずにビジネスロジックを記述できる。

---

## Route Groups によるレイヤー分離

Next.js App Router の Route Groups（括弧付きディレクトリ）を活用し、バックエンドのレイヤーをディレクトリ構造で明示した。

```
src/app/api/
├── (Controller)/   # ビジネスロジック層
├── (Repository)/   # データアクセス層
├── (LLM)/          # LLM プロバイダー層
├── (schema)/       # バリデーションスキーマ
├── trpc/           # tRPC ルーター定義
└── lib.ts          # 共通ユーティリティ
```

Route Groups は URL パスに影響を与えないため、純粋にコードの論理的な分類として機能する。
ディレクトリ名を見るだけで各ファイルの責務が把握でき、チームメンバーが迷わずにコードを配置できる。

